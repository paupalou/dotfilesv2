#!/bin/bash

source ./script/yaml_parser
source ./script/print_utils

function check_sudo {
	if ! command -v sudo &> /dev/null; then
		echo "sudo is not installed, install it (as root)"
		exit 1
	fi
}

function set_localtime {
	local localtime_file=/etc/localtime
	if [ ! -f "$localtime" ]; then
		local TZ=Europe/Madrid
		sudo ln -snf /usr/share/zoneinfo/$TZ /etc/localtime
	fi
}

function parse_software {
	eval $(parse_yaml $1)
}

function show_usage {
	printf "Usage: $0 [OPTION=PARAMETERS]\n"
	printf "Utility to synchronize your deps, apps and configs\n"
	printf "\n"
	printf "${uline}Options:\n$normal"
	print_help_option "-h, --help" "Print help"
	print_help_option "-i, --install" "Install all groups in install.yml"
	print_help_option "    --install=group" "Install only a group, must be defined in install.yml"
	print_help_option "-c, --config" "Symlink all files inside directory"
	print_help_option "-c, --config=directory" "Symlink specific directory"

	return 0
}

function link_file {
	local src=$1 dst=$2 print_each_skipped_file=$4
	local overwrite backup skip action

	if [ -f "$dst" -o -d "$dst" ]; then

		if [ "$overwrite_all" == "false" ] && [ "$backup_all" == "false" ] && [ "$skip_all" == "false" ]; then
			local currentSrc="$(readlink $dst)"
			if [ "$currentSrc" == "$src" ]; then
				if  [ "$print_each_skipped_file" != "false" ]; then
					success "skipped ${cyan}$src${normal}" "$3"
				fi
				return
			else

				user "${bold}$dst${normal} already exists, what to do?"
				user_option "[${bold}s${normal}]kip ───────────── [${bold}S${normal}]kip all"
				user_option "[${bold}o${normal}]verwrite ──────── [${bold}O${normal}]verwrite all"
				user_option "[${bold}b${normal}]ackup ─────────── [${bold}B${normal}]ackup all?"
				read -n 1 action

				case "$action" in
					o )
						overwrite=true;;
					O )
						overwrite_all=true;;
					b )
						backup=true;;
					B )
						backup_all=true;;
					s )
						skip=true;;
					S )
						skip_all=true;;
					* )
						;;
				esac
			fi
		fi

		overwrite=${overwrite:-$overwrite_all}
		backup=${backup:-$backup_all}
		skip=${skip:-$skip_all}

		if [ "$overwrite" == "true" ]; then
			rm -rf "$dst"
			success "removed ${cyan}$dst${normal}" "$3"
			((file_counter-=1))
		fi

		if [ "$backup" == "true" ]; then
			mv "$dst" "${dst}.backup"
			success "moved   ${cyan}$dst${normal} to ${dst}.backup" "$3"
			((file_counter-=1))
		fi

		if [ "$skip" == "true" ]; then
			success "skipped ${cyan}$src${normal}" "$3"
		fi
	fi

	if [ "$skip" != "true" ]; then
		ln -s "$src" "$dst"
		success "linked  ${lgreen}$2${normal}" "$3"
		((file_counter-=1))
	fi
}


function subfolder_files {
	local topic=$1
	local subfolder=$2
	# verbose is true by default and only applies to 'skip' action
	local verbose=${3:-'true'}

	# contains number of files skipped and used only when verbose is false
	local file_counter=0

	local overwrite_all=false backup_all=false skip_all=false
	for src in $(find -H $HOME/dotfiles/$topic/$subfolder -type f ! -path "*/.git/*" -type f ! -path "*/.*" -printf '%P\n')
	do
		local child_visual_line="──"
		local src_dirname="/$(dirname "$src")"

		# if we find symlink in first level assume src is 1st-child of $subfolder
		# so we unset src_dirname to avoid adding a dot (.)
		if [ $(dirname "$src") == "." ]; then
			src_dirname=""
		fi
		# local destiny_directory="$HOME/.$topic/$subfolder$src_dirname"
		local destiny_directory="$HOME/.$subfolder$src_dirname"
		((file_counter+=1))

		# check if destiny directory exists , create if not
		if [ ! -d $destiny_directory ]; then
			warn "creating directory → $destiny_directory${normal}" '──'
			mkdir -p "$destiny_directory"
			# double visual line to make visual appearance as child of this directory
			child_visual_line="──────"
		fi

		# build destiny with destiny_directory + file_name
		dst="$destiny_directory/$(basename "${src}")"

		# link the file
		link_file "$HOME/dotfiles/$topic/$subfolder/$src" "$dst" "$child_visual_line" "$verbose"
	done

	if [ $verbose == "false" ] && [ $file_counter -gt 0 ]; then
		success "skipped ${cyan}$file_counter${normal} files" "$child_visual_line"
	fi
}

function _not_match {
	for i in ${@}; do
		echo ! -name $i
	done
}

function symlink_files {
	_start 'linking dotfiles'

	local excluded_files=("path.fish")
	local exclude_file_list=$(_not_match ${excluded_files[@]})

	local files=$(find -H $HOME/dotfiles/ -mindepth 2 -maxdepth 2 -type f ! -path "*/.git/*" ! -path "*/script/*" $exclude_file_list)
	local overwrite_all=false backup_all=false skip_all=false

	local topics=$(find -H $HOME/dotfiles/ -mindepth 1 -maxdepth 1 -type d ! -path "*/.git" ! -path "*/script")

	for src in $files; do
		local dst="$HOME/.$(basename "${src%.*}")"
		echo $src
		echo $dst
		link_file $src $dst
	done

	for src in $(find $HOME/dotfiles/ -mindepth 2 -maxdepth 2 ! -path "*/.git/*" -type d -printf '%P\n' | sort)
	do
		local topic=$(dirname "$src")
		local subfolder=$(basename "$src")

		# print a title of this subfolder
		subfolder_title $bold$topic $normal$subfolder

		# link files inside subfolders
		# last argument is verbose, if you pass false a compact message will be printed
		subfolder_files $topic $subfolder false
	done

	_end
}

function install {
	check_sudo
	set_localtime
	local package_types

	if [ -z "$1" ]; then
		package_types=$__
	else
		package_types=$1
	fi

	for type in $package_types; do
		install_items $type
	done
}

function get_value {
	local prop=$1_$2
	local value=${!prop}
	if [ -n "$value" ]; then
		echo $value
	else
		echo $3
	fi
}

function _is_checker_loaded {
  if $(declare -f _is_${1}_installed); then
    true
    return
  fi

  false
  return
}

function _is_installer_loaded {
  if $(declare -f _install_${1}_from_${2}); then
    true
    return
  fi

  false
  return
}

function install_item {
	local item=$1
	local is_subitem=$2
	local is_last_item=$3
	local should_install=true

	local name=$(get_value $item "name")
	local from=$(get_value $item "from" $package_manager)
	local type=$(get_value $item "type" $package_type)
	local arch=$(get_value $item "arch" $package_arch)
	local bin=$(get_value $item "bin")
	local repository=$(get_value $item "repository")
	local release=$(get_value $item "release")
	local path=$(get_value $item "path")
	local run=$(get_value $item "run")
	local suffix=$(get_value $item "suffix")

  if ! _is_checker_loaded $type; then
    local checker=./script/$type.checker.sh
    if [ -f "$checker" ]; then
      source $checker
    fi
  fi

	if is_package_installed "$name" "$type" "$bin" "$is_subitem" "$is_last_item" ; then
		should_install=false
	fi

	local depends=${item}_depends_
	if [ -n "${!depends}" ]; then
		local index=1
		local dependencys=${!depends}
		local num_deps=$(echo "${dependencys}" | wc -w)
		for dependency in ${!depends}; do
			index=$(( index+1 ))
			local is_last_item
			if [ "$index" -gt "$num_deps" ];then
				is_last_item=true
			fi
			install_item $dependency true $is_last_item
		done
	fi

	if [ "$should_install" = true ]; then
    if ! _is_installer_loaded $type $from; then
      source ./script/$type.installer.from.$from.sh
    fi

    _install_${type}_from_${from} "$name" "$repository" "$release" "$path" "$run" "$is_subitem" "$arch"
  fi
}

function install_items {
	local items=$1
	local category=${items}_
  if [ -z "${!category}" ]; then
    return 0
  fi

	_start $items

	for item in ${!category}; do
		install_item $item
	done

	_end $items
}

function _run_command {
	eval "$1" &>/dev/null
}

function is_package_installed {
	local package=$1
  local type=$2
	local bin=$3
	local is_subitem=$4
	local is_last_item=$5
	local version

	if [ -z "$bin" ]; then
    version=$(_is_${type}_installed $package)
	else
		[ -f "$bin" ] && version="$($bin --version | head -1 | grep -o -e '[0-9]\+\(\.[0-9]\+\)*' | head -1)"
	fi

	if [ -z "$version" ]; then
		print_dependency_failed $package $is_subitem
		return 1
	fi

	print_dependency_success $package $version $is_subitem $is_last_item
	return 0
}

function install_source_from_github {
	local name=$1
	local repository=$2
	local destination_path=$4
	local run=$5

	print_installing $name "github"
	git clone --depth 1 https://github.com/${repository}.git ${destination_path} &>/dev/null
	command $destination_path/$run &>/dev/null

	echo $(pc "  ✓" $green$bold)
}

function install_binary_from_curl {
	local name=$1
	local run=$5

	print_installing $name "curl"

	_run_command "$run"

	echo $(pc "  ✓" $green$bold)
}
